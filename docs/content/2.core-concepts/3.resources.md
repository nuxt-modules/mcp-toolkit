---
title: Resources
description: Expose data sources as MCP resources with static or dynamic URIs.
navigation:
  icon: i-lucide-package
seo:
  title: Resources - Nuxt MCP Module
  description: Create MCP resources to expose data sources with static or dynamic URIs.
---

## What are Resources?

Resources provide access to data via URIs. They can represent files, database records, API endpoints, or any other data source that can be accessed through a URI.

## Static Resources

Static resources have a fixed URI that doesn't change:

```typescript [server/mcp/resources/readme.ts]
import { readFile } from 'node:fs/promises'
import { fileURLToPath } from 'node:url'

export default defineMcpResource({
  name: 'readme',
  title: 'README',
  uri: 'file:///README.md',
  metadata: {
    description: 'Project README file',
    mimeType: 'text/markdown',
  },
  handler: async (uri: URL) => {
    const filePath = fileURLToPath(uri)
    const content = await readFile(filePath, 'utf-8')
    return {
      contents: [{
        uri: uri.toString(),
        mimeType: 'text/markdown',
        text: content,
      }],
    }
  },
})
```

## Resource Structure

A resource definition consists of:

::code-group

```typescript [Required Fields]
export default defineMcpResource({
  name: 'resource-name',  // Unique identifier
  uri: 'uri://...',      // Static URI or ResourceTemplate
  handler: async (uri) => { // Handler function
    return { contents: [...] }
  },
})
```

```typescript [Optional Fields]
export default defineMcpResource({
  name: 'resource-name',
  title: 'Resource Title',        // Human-readable title
  uri: 'uri://...',
  metadata: { ... },              // Resource metadata
  handler: async (uri) => { ... },
})
```

::

## Dynamic Resources with Templates

Use `ResourceTemplate` to create dynamic resources that accept variables:

```typescript [server/mcp/resources/file.ts]
import { readFile } from 'node:fs/promises'
import { join } from 'node:path'
import { ResourceTemplate } from '@modelcontextprotocol/sdk/server/mcp.js'
import type { Variables } from '@modelcontextprotocol/sdk/shared/uriTemplate.js'

export default defineMcpResource({
  name: 'file',
  title: 'File Resource',
  uri: new ResourceTemplate('file:///project/{path}', {
    list: async () => {
      // Return list of available resources
      return {
        resources: [
          { uri: 'file:///project/README.md', name: 'README.md' },
          { uri: 'file:///project/src/index.ts', name: 'src/index.ts' },
        ],
      }
    },
  }),
  handler: async (uri: URL, variables: Variables) => {
    const path = variables.path as string
    const filePath = join(process.cwd(), path)
    const content = await readFile(filePath, 'utf-8')

    return {
      contents: [{
        uri: uri.toString(),
        mimeType: 'text/plain',
        text: content,
      }],
    }
  },
})
```

## ResourceTemplate

`ResourceTemplate` allows you to create resources with variable parts in the URI:

```typescript
new ResourceTemplate('file:///project/{path}', {
  list: async () => {
    // Optional: Return list of available resources
    return {
      resources: [
        { uri: 'file:///project/file1.txt', name: 'File 1' },
        { uri: 'file:///project/file2.txt', name: 'File 2' },
      ],
    }
  },
})
```

### Template Variables

Variables in the URI are defined with `{variableName}`:

```typescript
// Single variable
new ResourceTemplate('file:///project/{path}', { ... })

// Multiple variables
new ResourceTemplate('api://users/{userId}/posts/{postId}', { ... })
```

## Handler Function

The handler receives the resolved URI and optional variables:

```typescript
// Static resource handler
handler: async (uri: URL) => {
  return {
    contents: [{
      uri: uri.toString(),
      mimeType: 'text/plain',
      text: 'Content',
    }],
  }
}

// Dynamic resource handler
handler: async (uri: URL, variables: Variables) => {
  const path = variables.path as string
  // Use variables to resolve the resource
  return {
    contents: [{
      uri: uri.toString(),
      mimeType: 'text/plain',
      text: 'Content',
    }],
  }
}
```

## Resource Metadata

Add metadata to help clients understand the resource:

```typescript [server/mcp/resources/readme.ts]
export default defineMcpResource({
  name: 'readme',
  title: 'README',
  uri: 'file:///README.md',
  metadata: {
    description: 'Project README file',
    mimeType: 'text/markdown',
  },
  handler: async (uri: URL) => {
    // Implementation
  },
})
```

## Content Types

Resources can return different MIME types:

::code-group

```typescript [Text/Markdown]
return {
  contents: [{
    uri: uri.toString(),
    mimeType: 'text/markdown',
    text: '# Markdown content',
  }],
}
```

```typescript [JSON]
return {
  contents: [{
    uri: uri.toString(),
    mimeType: 'application/json',
    text: JSON.stringify({ key: 'value' }),
  }],
}
```

```typescript [Binary Data]
return {
  contents: [{
    uri: uri.toString(),
    mimeType: 'image/png',
    blob: Buffer.from(binaryData),
  }],
}
```

::

## Error Handling

Handle errors gracefully in your handlers:

```typescript [server/mcp/resources/readme.ts]
import { readFile } from 'node:fs/promises'
import { fileURLToPath } from 'node:url'

export default defineMcpResource({
  name: 'readme',
  uri: 'file:///README.md',
  handler: async (uri: URL) => {
    try {
      const filePath = fileURLToPath(uri)
      const content = await readFile(filePath, 'utf-8')

      return {
        contents: [{
          uri: uri.toString(),
          mimeType: 'text/markdown',
          text: content,
        }],
      }
    }
    catch (error) {
      return {
        contents: [{
          uri: uri.toString(),
          mimeType: 'text/plain',
          text: `Error: ${error instanceof Error ? error.message : String(error)}`,
        }],
        isError: true,
      }
    }
  },
})
```

## Advanced Examples

### Dynamic Resource with Template

Here's a simple example using `ResourceTemplate` for dynamic resources:

```typescript [server/mcp/resources/file.ts]
import { readFile } from 'node:fs/promises'
import { join } from 'node:path'
import { ResourceTemplate } from '@modelcontextprotocol/sdk/server/mcp.js'
import type { Variables } from '@modelcontextprotocol/sdk/shared/uriTemplate.js'

export default defineMcpResource({
  name: 'file',
  title: 'File Resource',
  uri: new ResourceTemplate('file:///project/{path}', {
    list: async () => {
      // Return list of available resources
      return {
        resources: [
          { uri: 'file:///project/README.md', name: 'README.md' },
          { uri: 'file:///project/package.json', name: 'package.json' },
        ],
      }
    },
  }),
  handler: async (uri: URL, variables: Variables) => {
    const path = variables.path as string
    const filePath = join(process.cwd(), path)
    const content = await readFile(filePath, 'utf-8')

    return {
      contents: [{
        uri: uri.toString(),
        mimeType: 'text/plain',
        text: content,
      }],
    }
  },
})
```

## File Organization

Organize your resources in the `server/mcp/resources/` directory:

```
server/
└── mcp/
    └── resources/
        ├── readme.ts
        └── file.ts
```

Each file should export a default resource definition.

## URI Schemes

You can use any URI scheme that makes sense for your use case:

- `file://` - File system resources
- `api://` - API endpoints
- `http://` / `https://` - Web resources
- `custom://` - Custom schemes

## Next Steps

- [Tools](/core-concepts/tools) - Create tools to perform actions
- [Prompts](/core-concepts/prompts) - Create reusable prompts
- [Handlers](/core-concepts/handlers) - Create custom MCP endpoints
- [Examples](/examples/file-operations) - More resource examples
