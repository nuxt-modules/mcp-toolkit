---
title: Tools
description: Create MCP tools with Zod validation and type safety.
navigation:
  icon: i-lucide-wrench
seo:
  title: Tools - Nuxt MCP Module
  description: Create MCP tools with Zod validation and full TypeScript support.
---

## What are Tools?

Tools are functions that AI assistants can call to perform actions or retrieve information. They accept validated input parameters and return structured results.

## Basic Tool Definition

Here's a simple tool that echoes back a message:

```typescript [server/mcp/tools/echo.ts]
import { z } from 'zod'

export default defineMcpTool({
  name: 'echo',
  description: 'Echo back a message',
  inputSchema: {
    message: z.string().describe('The message to echo back'),
  },
  handler: async ({ message }) => {
    return {
      content: [{
        type: 'text',
        text: `Echo: ${message}`,
      }],
    }
  },
})
```

## Tool Structure

A tool definition consists of:

::code-group

```typescript [Required Fields]
export default defineMcpTool({
  name: 'tool-name',        // Unique identifier
  inputSchema: { ... },      // Zod schema for input validation
  handler: async (args) => { // Handler function
    return { content: [...] }
  },
})
```

```typescript [Optional Fields]
export default defineMcpTool({
  name: 'tool-name',
  title: 'Tool Title',              // Human-readable title
  description: 'Tool description',  // What the tool does
  inputSchema: { ... },
  outputSchema: { ... },            // Zod schema for structured output
  annotations: { ... },             // Tool annotations
  handler: async (args) => { ... },
})
```

::

## Input Schema

The `inputSchema` uses Zod to define and validate input parameters. Each field must be a Zod schema:

```typescript [server/mcp/tools/calculator.ts]
import { z } from 'zod'

export default defineMcpTool({
  name: 'calculator',
  inputSchema: {
    // String input
    operation: z.string().describe('Operation to perform'),

    // Number input
    a: z.number().describe('First number'),
    b: z.number().describe('Second number'),

    // Optional field
    precision: z.number().optional().describe('Decimal precision'),

    // Enum input
    format: z.enum(['decimal', 'fraction']).describe('Output format'),

    // Array input
    numbers: z.array(z.number()).describe('List of numbers'),
  },
  handler: async ({ operation, a, b, precision, format, numbers }) => {
    // Handler implementation
  },
})
```

### Common Zod Types

::prose-table
| Zod Type | Example | Description |
|----------|---------|-------------|
| `z.string()` | `z.string().min(1).max(100)` | String with validation |
| `z.number()` | `z.number().min(0).max(100)` | Number with validation |
| `z.boolean()` | `z.boolean()` | Boolean value |
| `z.array()` | `z.array(z.string())` | Array of values |
| `z.object()` | `z.object({ ... })` | Nested object |
| `z.enum()` | `z.enum(['a', 'b'])` | Enumeration |
| `z.optional()` | `z.string().optional()` | Optional field |
| `z.default()` | `z.string().default('value')` | Field with default |

::

## Output Schema

Define structured output using `outputSchema`:

```typescript [server/mcp/tools/bmi.ts]
import { z } from 'zod'

export default defineMcpTool({
  name: 'calculate-bmi',
  description: 'Calculate Body Mass Index',
  inputSchema: {
    weightKg: z.number().describe('Weight in kilograms'),
    heightM: z.number().describe('Height in meters'),
  },
  outputSchema: {
    bmi: z.number(),
    category: z.string(),
  },
  handler: async ({ weightKg, heightM }) => {
    const bmi = weightKg / (heightM * heightM)
    let category = 'Normal'
    if (bmi < 18.5) category = 'Underweight'
    else if (bmi >= 25) category = 'Overweight'
    else if (bmi >= 30) category = 'Obese'

    return {
      content: [{
        type: 'text',
        text: `BMI: ${bmi.toFixed(2)} (${category})`,
      }],
      structuredContent: {
        bmi: Math.round(bmi * 100) / 100,
        category,
      },
    }
  },
})
```

The `structuredContent` field provides structured data that matches your `outputSchema`, making it easier for AI assistants to work with the results.

## Handler Function

The handler is an async function that receives validated input and returns results:

```typescript
handler: async (args, extra) => {
  // args: Validated input matching inputSchema
  // extra: Request handler extra information

  return {
    content: [{
      type: 'text',
      text: 'Result text',
    }],
    structuredContent: { ... }, // Optional structured output
  }
}
```

### Content Types

Tools can return different content types:

::code-group

```typescript [Text Content]
return {
  content: [{
    type: 'text',
    text: 'Hello, world!',
  }],
}
```

```typescript [Image Content]
return {
  content: [{
    type: 'image',
    data: base64ImageData,
    mimeType: 'image/png',
  }],
}
```

```typescript [Resource Reference]
return {
  content: [{
    type: 'resource',
    resource: {
      uri: 'file:///path/to/file',
      text: 'File content',
      mimeType: 'text/plain',
    },
  }],
}
```

::

## Tool Annotations

Add metadata to tools using annotations:

```typescript [server/mcp/tools/search.ts]
import { z } from 'zod'

export default defineMcpTool({
  name: 'search',
  description: 'Search the web',
  inputSchema: {
    query: z.string().describe('Search query'),
  },
  annotations: {
    // Mark tool as requiring user confirmation
    requiresConfirmation: true,
    // Add custom metadata
    category: 'search',
    rateLimit: '10/minute',
  },
  handler: async ({ query }) => {
    // Implementation
  },
})
```

## Error Handling

Handle errors gracefully in your handlers:

```typescript [server/mcp/tools/safe-divide.ts]
import { z } from 'zod'

export default defineMcpTool({
  name: 'safe-divide',
  inputSchema: {
    a: z.number(),
    b: z.number(),
  },
  handler: async ({ a, b }) => {
    if (b === 0) {
      return {
        content: [{
          type: 'text',
          text: 'Error: Division by zero',
        }],
        isError: true,
      }
    }

    const result = a / b
    return {
      content: [{
        type: 'text',
        text: `Result: ${result}`,
      }],
    }
  },
})
```

## Advanced Examples

### Tool with Error Handling

Here's an example showing proper error handling:

```typescript [server/mcp/tools/safe-operation.ts]
import { z } from 'zod'

export default defineMcpTool({
  name: 'safe-operation',
  description: 'Perform an operation with error handling',
  inputSchema: {
    value: z.string().describe('Input value'),
  },
  handler: async ({ value }) => {
    try {
      // Your operation here
      const result = value.toUpperCase()

      return {
        content: [{
          type: 'text',
          text: `Result: ${result}`,
        }],
      }
    }
    catch (error) {
      return {
        content: [{
          type: 'text',
          text: `Error: ${error instanceof Error ? error.message : String(error)}`,
        }],
        isError: true,
      }
    }
  },
})
```

## File Organization

Organize your tools in the `server/mcp/tools/` directory:

```
server/
└── mcp/
    └── tools/
        ├── echo.ts
        ├── calculator.ts
        ├── bmi.ts
        └── text-processor.ts
```

Each file should export a default tool definition.

## Type Safety

The module provides full TypeScript type inference:

```typescript
// Input types are inferred from inputSchema
handler: async ({ message }) => {
  // message is typed as string
}

// Output types are inferred from outputSchema
const result = {
  structuredContent: {
    bmi: 25.5,      // number
    category: '...', // string
  },
}
```

## Next Steps

- [Resources](/core-concepts/resources) - Create resources to expose data
- [Prompts](/core-concepts/prompts) - Create reusable prompts
- [Handlers](/core-concepts/handlers) - Create custom MCP endpoints
- [Examples](/examples/common-patterns) - See more tool examples
