---
title: Multiple Handlers
description: Create and manage multiple MCP endpoints in a single application.
navigation:
  icon: i-lucide-layers
seo:
  title: Multiple Handlers - Nuxt MCP Module
  description: Create multiple MCP endpoints with different tools, resources, and prompts.
---

## Overview

The Nuxt MCP module supports creating multiple MCP handlers in a single application. Each handler can have its own route, version, tools, resources, and prompts.

## Why Multiple Handlers?

Multiple handlers are useful for:

- **Feature Separation**: Separate different features into different endpoints
- **Versioning**: Create versioned APIs (v1, v2, etc.)
- **Domain Organization**: Organize by domain (users, products, analytics)
- **Access Control**: Different handlers for different access levels
- **Modularity**: Keep related functionality together

## Creating Multiple Handlers

Create multiple handlers by exporting `defineMcpHandler` from different files:

```
server/
└── mcp/
    ├── users.ts          # User management handler
    ├── products.ts       # Product management handler
    ├── analytics.ts      # Analytics handler
    ├── admin.ts          # Admin handler
    └── tools/
        └── # Tools for default handler
```

### Example: User Handler

```typescript [server/mcp/users.ts]
import { z } from 'zod'

const getUserTool = defineMcpTool({
  name: 'get-user',
  description: 'Get user by ID',
  inputSchema: {
    userId: z.string(),
  },
  handler: async ({ userId }) => {
    const user = await db.users.find(userId)
    return {
      content: [{
        type: 'text',
        text: JSON.stringify(user),
      }],
    }
  },
})

const createUserTool = defineMcpTool({
  name: 'create-user',
  description: 'Create a new user',
  inputSchema: {
    name: z.string(),
    email: z.string().email(),
  },
  handler: async ({ name, email }) => {
    const user = await db.users.create({ name, email })
    return {
      content: [{
        type: 'text',
        text: `User created: ${user.id}`,
      }],
    }
  },
})

export default defineMcpHandler({
  name: 'users',
  version: '1.0.0',
  route: '/mcp/users',
  tools: [getUserTool, createUserTool],
})
```

### Example: Product Handler

```typescript [server/mcp/products.ts]
import { z } from 'zod'

const getProductTool = defineMcpTool({
  name: 'get-product',
  description: 'Get product by ID',
  inputSchema: {
    productId: z.string(),
  },
  handler: async ({ productId }) => {
    const product = await db.products.find(productId)
    return {
      content: [{
        type: 'text',
        text: JSON.stringify(product),
      }],
    }
  },
})

const listProductsTool = defineMcpTool({
  name: 'list-products',
  description: 'List all products',
  inputSchema: {
    category: z.string().optional(),
  },
  handler: async ({ category }) => {
    const products = category
      ? await db.products.findByCategory(category)
      : await db.products.findAll()

    return {
      content: [{
        type: 'text',
        text: JSON.stringify(products),
      }],
    }
  },
})

export default defineMcpHandler({
  name: 'products',
  version: '1.0.0',
  route: '/mcp/products',
  tools: [getProductTool, listProductsTool],
})
```

### Example: Analytics Handler

```typescript [server/mcp/analytics.ts]
import { z } from 'zod'

const getStatsTool = defineMcpTool({
  name: 'get-stats',
  description: 'Get analytics statistics',
  inputSchema: {
    period: z.enum(['day', 'week', 'month']),
  },
  handler: async ({ period }) => {
    const stats = await analytics.getStats(period)
    return {
      content: [{
        type: 'text',
        text: JSON.stringify(stats),
      }],
    }
  },
})

const generateReportTool = defineMcpTool({
  name: 'generate-report',
  description: 'Generate analytics report',
  inputSchema: {
    startDate: z.string(),
    endDate: z.string(),
    format: z.enum(['json', 'csv']).default('json'),
  },
  handler: async ({ startDate, endDate, format }) => {
    const report = await analytics.generateReport(startDate, endDate, format)
    return {
      content: [{
        type: 'text',
        text: report,
      }],
    }
  },
})

export default defineMcpHandler({
  name: 'analytics',
  version: '1.0.0',
  route: '/mcp/analytics',
  tools: [getStatsTool, generateReportTool],
})
```

## Handler Routes

Each handler is accessible at `/mcp/:handler`:

- `users` handler → `/mcp/users`
- `products` handler → `/mcp/products`
- `analytics` handler → `/mcp/analytics`

You can also specify custom routes:

```typescript
export default defineMcpHandler({
  name: 'users',
  route: '/api/v1/users/mcp', // Custom route
})
```

## Default Handler

The default handler (at `/mcp`) includes all tools, resources, and prompts from:
- `server/mcp/tools/`
- `server/mcp/resources/`
- `server/mcp/prompts/`

Custom handlers are separate and don't include these unless explicitly added.

## Sharing Tools Between Handlers

You can share tool definitions between handlers:

```typescript [server/mcp/shared-tools.ts]
import { z } from 'zod'

export const sharedTool = defineMcpTool({
  name: 'shared-tool',
  description: 'A shared tool',
  inputSchema: {
    input: z.string(),
  },
  handler: async ({ input }) => {
    return {
      content: [{
        type: 'text',
        text: `Shared: ${input}`,
      }],
    }
  },
})
```

```typescript [server/mcp/handler1.ts]
import { sharedTool } from './shared-tools'

export default defineMcpHandler({
  name: 'handler1',
  tools: [sharedTool],
})
```

```typescript [server/mcp/handler2.ts]
import { sharedTool } from './shared-tools'

export default defineMcpHandler({
  name: 'handler2',
  tools: [sharedTool],
})
```

## Versioned Handlers

Create versioned handlers for API versioning:

```typescript [server/mcp/api-v1.ts]
export default defineMcpHandler({
  name: 'api-v1',
  version: '1.0.0',
  route: '/api/v1/mcp',
  tools: [ /* v1 tools */ ],
})
```

```typescript [server/mcp/api-v2.ts]
export default defineMcpHandler({
  name: 'api-v2',
  version: '2.0.0',
  route: '/api/v2/mcp',
  tools: [ /* v2 tools */ ],
})
```

## Handler with Resources and Prompts

Handlers can include resources and prompts:

```typescript [server/mcp/full-handler.ts]
const tool = defineMcpTool({ ... })
const resource = defineMcpResource({ ... })
const prompt = defineMcpPrompt({ ... })

export default defineMcpHandler({
  name: 'full',
  tools: [tool],
  resources: [resource],
  prompts: [prompt],
})
```

## Complete Example

Here's a complete example with multiple handlers:

```
server/
└── mcp/
    ├── users.ts
    ├── products.ts
    ├── analytics.ts
    ├── admin.ts
    ├── tools/
    │   └── echo.ts
    ├── resources/
    │   └── readme.ts
    └── prompts/
        └── greeting.ts
```

```typescript [Complete Setup]
// Default handler includes:
// - server/mcp/tools/echo.ts
// - server/mcp/resources/readme.ts
// - server/mcp/prompts/greeting.ts
// Accessible at: /mcp

// Custom handlers:
// - server/mcp/users.ts → /mcp/users
// - server/mcp/products.ts → /mcp/products
// - server/mcp/analytics.ts → /mcp/analytics
// - server/mcp/admin.ts → /mcp/admin
```

## Best Practices

1. **Use descriptive names**: Make handler names clear and specific
2. **Group related functionality**: Put related tools/resources together
3. **Version your handlers**: Use semantic versioning
4. **Document handlers**: Add comments explaining what each handler does
5. **Keep handlers focused**: Each handler should have a clear purpose
6. **Share common code**: Extract shared tools/resources to separate files

## Next Steps

- [Handlers](/core-concepts/handlers) - Learn more about handlers
- [Custom Paths](/advanced/custom-paths) - Customize directory structure
- [Examples](/examples/common-patterns) - See more examples
