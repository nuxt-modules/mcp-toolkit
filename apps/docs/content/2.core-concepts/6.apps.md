---
title: Apps
description: Create MCP Apps with interactive UI that displays in MCP hosts.
navigation:
  icon: i-lucide-layout-dashboard
seo:
  title: MCP Apps
  description: Create MCP Apps with interactive UI for Claude Desktop, VS Code, and other MCP-compatible clients.
---

## What are MCP Apps?

MCP Apps are tools that return interactive user interfaces. When called by an AI assistant, they display a rich UI in the host application (like Claude Desktop or VS Code) instead of just returning text.

An MCP App consists of:
- A **tool** that the AI assistant calls
- A **UI resource** (HTML) that renders in an iframe

The module handles the linking between the tool and its UI automatically.

## Basic App Definition

Here's a simple app that displays a greeting:

```typescript [server/mcp/apps/greeting.ts]
import { z } from 'zod'

export default defineMcpApp({
  description: 'Display a personalized greeting',
  inputSchema: {
    name: z.string().describe('Name to greet'),
  },
  ui: {
    html: `<!DOCTYPE html>
<html>
<head>
  <style>
    body { font-family: system-ui; padding: 20px; text-align: center; }
    h1 { color: #3b82f6; }
  </style>
</head>
<body>
  <h1 id="greeting">Loading...</h1>
  <script>
    window.addEventListener('message', (event) => {
      if (event.data?.method === 'ui/notifications/tool-result') {
        const text = event.data.params?.content?.[0]?.text || 'Hello!';
        document.getElementById('greeting').textContent = text;
      }
    });
    
    // Initialize connection
    window.parent.postMessage({
      jsonrpc: '2.0',
      id: 1,
      method: 'ui/initialize',
      params: {
        appCapabilities: {},
        appInfo: { name: 'Greeting App', version: '1.0.0' },
        protocolVersion: '2025-06-18'
      }
    }, '*');
  </script>
</body>
</html>`,
  },
  handler: async ({ name }) => {
    return {
      content: [{
        type: 'text',
        text: `Hello, ${name}! Welcome to MCP Apps.`,
      }],
    }
  },
})
```

## App Structure

An app definition consists of:

```typescript
import { z } from 'zod'

export default defineMcpApp({
  // Tool metadata (optional - auto-generated from filename)
  name: 'my-app',
  title: 'My App',
  description: 'What the app does',
  
  // Input validation
  inputSchema: {
    param: z.string().describe('Parameter description'),
  },
  
  // UI configuration (required)
  ui: {
    html: '...', // HTML content
    csp: { ... }, // Content Security Policy
    visibility: ['model', 'app'], // Who can access
    prefersBorder: true, // Visual boundary
  },
  
  // Tool handler
  handler: async (args) => {
    return { content: [...] }
  },
})
```

## UI Configuration

The `ui` object configures how your app's interface is rendered:

### HTML Content

Provide HTML as an inline string:

```typescript
ui: {
  html: `<!DOCTYPE html>
<html>
  <head>
    <style>/* Your styles */</style>
  </head>
  <body>
    <div id="app"></div>
    <script>/* Your JavaScript */</script>
  </body>
</html>`,
}
```

### Content Security Policy

Control which external domains your app can access:

```typescript
ui: {
  html: '...',
  csp: {
    // Allow API calls to these domains
    connectDomains: ['https://api.example.com'],
    // Allow loading resources from these domains
    resourceDomains: ['https://cdn.example.com'],
    // Allow embedding iframes from these domains
    frameDomains: ['https://youtube.com'],
  },
}
```

### Visibility

Control who can call the app's tool:

```typescript
ui: {
  html: '...',
  visibility: ['model', 'app'], // Default: both can call
  // visibility: ['model'], // Only AI can call
  // visibility: ['app'], // Only UI can call (hidden from AI)
}
```

### Visual Preferences

```typescript
ui: {
  html: '...',
  prefersBorder: true, // Request visible border around the UI
}
```

## UI Communication Protocol

Your app communicates with the host using JSON-RPC 2.0 over `postMessage`.

### Initialization

Apps must initialize the connection:

```javascript
// Send initialize request
window.parent.postMessage({
  jsonrpc: '2.0',
  id: 1,
  method: 'ui/initialize',
  params: {
    appCapabilities: {},
    appInfo: { name: 'My App', version: '1.0.0' },
    protocolVersion: '2025-06-18'
  }
}, '*');

// Send initialized notification after receiving response
window.parent.postMessage({
  jsonrpc: '2.0',
  method: 'ui/notifications/initialized',
  params: {}
}, '*');
```

### Receiving Tool Results

Listen for tool input and results:

```javascript
window.addEventListener('message', (event) => {
  const data = event.data;
  if (!data || typeof data !== 'object') return;

  // Tool input (arguments passed to the tool)
  if (data.method === 'ui/notifications/tool-input') {
    const args = data.params?.arguments || {};
    console.log('Tool called with:', args);
  }

  // Tool result (returned by handler)
  if (data.method === 'ui/notifications/tool-result') {
    const result = data.params;
    console.log('Result:', result.content);
    console.log('Structured:', result.structuredContent);
  }
});
```

### Calling Tools from UI

The UI can call tools on the server:

```javascript
// Request function
function callTool(name, args) {
  const id = Date.now();
  window.parent.postMessage({
    jsonrpc: '2.0',
    id,
    method: 'tools/call',
    params: { name, arguments: args }
  }, '*');
}

// Example: Refresh data
document.getElementById('refresh').onclick = () => {
  callTool('my-app', { param: 'new-value' });
};
```

### Updating Model Context

Keep the AI informed of UI state changes:

```javascript
function updateContext(content) {
  window.parent.postMessage({
    jsonrpc: '2.0',
    id: Date.now(),
    method: 'ui/update-model-context',
    params: {
      content: [{ type: 'text', text: content }],
      structuredContent: { /* structured data */ }
    }
  }, '*');
}
```

## Theming

Host applications provide CSS variables for consistent styling:

```css
.container {
  background: var(--color-background-primary, #fff);
  color: var(--color-text-primary, #000);
  font-family: var(--font-sans, system-ui);
  border-radius: var(--border-radius-md, 8px);
}
```

### Available CSS Variables

| Category | Variables |
|----------|-----------|
| Background | `--color-background-primary`, `--color-background-secondary` |
| Text | `--color-text-primary`, `--color-text-secondary`, `--color-text-muted` |
| Border | `--color-border-primary`, `--color-border-secondary` |
| Typography | `--font-sans`, `--font-mono` |
| Spacing | `--border-radius-sm`, `--border-radius-md`, `--border-radius-lg` |

## Complete Example: Interactive Counter

Here's a full example of an interactive counter app:

```typescript [server/mcp/apps/counter.ts]
import { z } from 'zod'

export default defineMcpApp({
  name: 'counter',
  title: 'Interactive Counter',
  description: 'An interactive counter with increment/decrement buttons',
  inputSchema: {
    initialValue: z.number().default(0).describe('Starting value'),
  },
  ui: {
    html: `<!DOCTYPE html>
<html>
<head>
  <style>
    body {
      font-family: var(--font-sans, system-ui);
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 150px;
      background: var(--color-background-primary, #f5f5f5);
      color: var(--color-text-primary, #1a1a1a);
    }
    .container {
      text-align: center;
      background: var(--color-background-secondary, white);
      padding: 24px;
      border-radius: var(--border-radius-lg, 12px);
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    .count {
      font-size: 3rem;
      font-weight: bold;
      margin: 16px 0;
    }
    .buttons { display: flex; gap: 12px; justify-content: center; }
    button {
      font-size: 1.5rem;
      width: 48px;
      height: 48px;
      border: none;
      border-radius: var(--border-radius-md, 8px);
      background: #3b82f6;
      color: white;
      cursor: pointer;
    }
    button:hover { background: #2563eb; }
  </style>
</head>
<body>
  <div class="container">
    <h2>Counter</h2>
    <div class="count" id="count">0</div>
    <div class="buttons">
      <button id="dec">−</button>
      <button id="inc">+</button>
    </div>
  </div>
  <script>
    let count = 0;
    const countEl = document.getElementById('count');
    
    // Initialize
    window.parent.postMessage({
      jsonrpc: '2.0', id: 1,
      method: 'ui/initialize',
      params: {
        appCapabilities: {},
        appInfo: { name: 'Counter', version: '1.0.0' },
        protocolVersion: '2025-06-18'
      }
    }, '*');
    
    // Handle messages
    window.addEventListener('message', (e) => {
      if (e.data?.method === 'ui/notifications/tool-input') {
        count = e.data.params?.arguments?.initialValue ?? 0;
        countEl.textContent = count;
      }
    });
    
    // Update count and notify host
    function updateCount(delta) {
      count += delta;
      countEl.textContent = count;
      window.parent.postMessage({
        jsonrpc: '2.0', id: Date.now(),
        method: 'ui/update-model-context',
        params: {
          content: [{ type: 'text', text: 'Counter: ' + count }],
          structuredContent: { count }
        }
      }, '*');
    }
    
    document.getElementById('inc').onclick = () => updateCount(1);
    document.getElementById('dec').onclick = () => updateCount(-1);
  </script>
</body>
</html>`,
    prefersBorder: true,
  },
  handler: async ({ initialValue }) => ({
    content: [{
      type: 'text',
      text: `Counter initialized at ${initialValue}`,
    }],
    structuredContent: { initialValue },
  }),
})
```

## Testing MCP Apps

### Using MCP Inspector

The built-in MCP Inspector in Nuxt DevTools supports MCP Apps:

1. Start your development server: `pnpm dev`
2. Open Nuxt DevTools
3. Navigate to the MCP Inspector tab
4. Select your app's tool and call it
5. The UI will render in the inspector

### Using basic-host

For more comprehensive testing, use the [basic-host](https://github.com/modelcontextprotocol/ext-apps/tree/main/examples/basic-host) reference implementation:

```bash
# Terminal 1: Start your Nuxt app
pnpm dev

# Terminal 2: Run basic-host
git clone https://github.com/modelcontextprotocol/ext-apps.git
cd ext-apps/examples/basic-host
npm install
SERVERS='["http://localhost:3000/mcp"]' npm start
# Open http://localhost:8080
```

### Testing with Claude.ai

To test with Claude.ai using a tunnel:

```bash
# Start your app
pnpm dev

# Create a public tunnel
npx cloudflared tunnel --url http://localhost:3000

# Add the generated URL as an MCP server in Claude.ai
```

## File Organization

Organize your apps in the `server/mcp/apps/` directory:

```
server/
└── mcp/
    └── apps/
        ├── counter.ts
        ├── weather.ts
        └── dashboard.ts
```

## Best Practices

1. **Keep HTML self-contained** - Bundle all CSS and JavaScript inline
2. **Use CSS variables** - Respect host theming for visual consistency
3. **Handle all message types** - Implement proper initialization and error handling
4. **Provide text fallback** - Always return meaningful text content for non-UI hosts
5. **Update model context** - Keep the AI informed of UI state changes
6. **Test across hosts** - Different hosts may have slightly different behaviors

## Compatibility

MCP Apps are supported by hosts that implement the [MCP Apps Extension (SEP-1865)](https://github.com/modelcontextprotocol/ext-apps):

- Claude Desktop
- VS Code (Insiders)
- Goose
- Other MCP-compatible clients

Hosts that don't support MCP Apps will still receive the text content from your handler, ensuring graceful degradation.

## Next Steps

- [Tools](/core-concepts/tools) - Learn about regular tools
- [Resources](/core-concepts/resources) - Create data resources
- [Handlers](/core-concepts/handlers) - Create custom MCP endpoints
- [Examples](/examples/common-patterns) - See more patterns
